-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ANN\HDL_ANN.vhd
-- Created: 2022-05-13 14:13:53
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 40
-- Target subsystem base rate: 40
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        40
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- output                        ce_out        40
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: HDL_ANN
-- Source Path: ANN/HDL_ANN
-- Hierarchy Level: 0
-- 
-- Simulink model description for ANN:
-- 
-- Symmetric FIR Filter
-- This example shows how to use HDL Coder(TM) to check, generate,
-- and verify HDL for a fixed-point symmetric FIR filter. 
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_ANN_pkg.ALL;

ENTITY HDL_ANN IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        opcode                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        input_0                           :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
        input_1                           :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
        target                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
        alpha                             :   IN    std_logic_vector(17 DOWNTO 0);  -- ufix18_En18
        ce_out                            :   OUT   std_logic;
        output                            :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En12
        );
END HDL_ANN;


ARCHITECTURE rtl OF HDL_ANN IS

  -- Component Declarations
  COMPONENT Enabled_Subsystem1
    PORT( x                               :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          y                               :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
          a1                              :   IN    vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
          a2                              :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          a3                              :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
          w1                              :   IN    matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
          w2                              :   IN    matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
          w3                              :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          b1                              :   IN    vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
          b2                              :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          b3                              :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
          alpha                           :   IN    std_logic_vector(17 DOWNTO 0);  -- ufix18_En18
          updated_w1                      :   OUT   matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
          updated_w2                      :   OUT   matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
          updated_w3                      :   OUT   vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          updated_b1                      :   OUT   vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
          updated_b2                      :   OUT   vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          updated_b3                      :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En12
          );
  END COMPONENT;

  COMPONENT Enabled_Subsystem
    PORT( x                               :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          w1                              :   IN    matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
          w2                              :   IN    matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
          w3                              :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          b1                              :   IN    vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
          b2                              :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          b3                              :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En12
          Enable                          :   IN    std_logic;
          a1                              :   OUT   vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
          a2                              :   OUT   vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
          a3                              :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Enabled_Subsystem1
    USE ENTITY work.Enabled_Subsystem1(rtl);

  FOR ALL : Enabled_Subsystem
    USE ENTITY work.Enabled_Subsystem(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL input                            : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL b3_out1                          : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL b2_out1                          : vector_of_signed18(0 TO 1);  -- sfix18_En12 [2]
  SIGNAL b2_out1_1                        : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL b1_out1                          : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL b1_out1_1                        : vector_of_std_logic_vector18(0 TO 3);  -- ufix18 [4]
  SIGNAL w3_out1                          : vector_of_signed18(0 TO 1);  -- sfix18_En12 [2]
  SIGNAL w3_out1_1                        : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL w2_out1                          : matrix_of_signed18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
  SIGNAL w2_out1_1                        : matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- ufix18 [2x4]
  SIGNAL Enabled_Subsystem1_out6          : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL Enabled_Subsystem1_out6_signed   : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Enabled_Subsystem1_out5          : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Enabled_Subsystem1_out5_signed   : vector_of_signed18(0 TO 1);  -- sfix18_En12 [2]
  SIGNAL b2_out1_2                        : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Enabled_Subsystem1_out4          : vector_of_std_logic_vector18(0 TO 3);  -- ufix18 [4]
  SIGNAL Enabled_Subsystem1_out4_signed   : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL b1_out1_2                        : vector_of_std_logic_vector18(0 TO 3);  -- ufix18 [4]
  SIGNAL Enabled_Subsystem1_out3          : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Enabled_Subsystem1_out3_signed   : vector_of_signed18(0 TO 1);  -- sfix18_En12 [2]
  SIGNAL w3_out1_2                        : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Enabled_Subsystem1_out2          : matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- ufix18 [2x4]
  SIGNAL Enabled_Subsystem1_out2_signed   : matrix_of_signed18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
  SIGNAL c45_Enabled_Subsystem1_out2      : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL c45_w2_out1                      : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL w2_out1_2                        : matrix_of_std_logic_vector18(0 TO 1, 0 TO 3);  -- ufix18 [2x4]
  SIGNAL w1_out1                          : matrix_of_signed18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
  SIGNAL w1_out1_1                        : matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- ufix18 [4x2]
  SIGNAL Enabled_Subsystem_out1           : vector_of_std_logic_vector18(0 TO 3);  -- ufix18 [4]
  SIGNAL Enabled_Subsystem_out2           : vector_of_std_logic_vector18(0 TO 1);  -- ufix18 [2]
  SIGNAL Enabled_Subsystem_out3           : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL Enabled_Subsystem1_out1          : matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- ufix18 [4x2]
  SIGNAL Enabled_Subsystem1_out1_signed   : matrix_of_signed18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
  SIGNAL c44_Enabled_Subsystem1_out1      : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL c44_w1_out1                      : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL w1_out1_2                        : matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- ufix18 [4x2]

BEGIN
  u_Enabled_Subsystem1 : Enabled_Subsystem1
    PORT MAP( x => input,  -- sfix18_En12 [2]
              y => target,  -- sfix18_En12
              a1 => Enabled_Subsystem_out1,  -- sfix18_En12 [4]
              a2 => Enabled_Subsystem_out2,  -- sfix18_En12 [2]
              a3 => Enabled_Subsystem_out3,  -- sfix18_En12
              w1 => w1_out1_1,  -- sfix18_En12 [4x2]
              w2 => w2_out1_2,  -- sfix18_En12 [2x4]
              w3 => w3_out1_2,  -- sfix18_En12 [2]
              b1 => b1_out1_2,  -- sfix18_En12 [4]
              b2 => b2_out1_2,  -- sfix18_En12 [2]
              b3 => std_logic_vector(b3_out1),  -- sfix18_En12
              alpha => alpha,  -- ufix18_En18
              updated_w1 => Enabled_Subsystem1_out1,  -- sfix18_En12 [4x2]
              updated_w2 => Enabled_Subsystem1_out2,  -- sfix18_En12 [2x4]
              updated_w3 => Enabled_Subsystem1_out3,  -- sfix18_En12 [2]
              updated_b1 => Enabled_Subsystem1_out4,  -- sfix18_En12 [4]
              updated_b2 => Enabled_Subsystem1_out5,  -- sfix18_En12 [2]
              updated_b3 => Enabled_Subsystem1_out6  -- sfix18_En12
              );

  u_Enabled_Subsystem : Enabled_Subsystem
    PORT MAP( x => input,  -- sfix18_En12 [2]
              w1 => w1_out1_2,  -- sfix18_En12 [4x2]
              w2 => w2_out1_1,  -- sfix18_En12 [2x4]
              w3 => w3_out1_1,  -- sfix18_En12 [2]
              b1 => b1_out1_1,  -- sfix18_En12 [4]
              b2 => b2_out1_1,  -- sfix18_En12 [2]
              b3 => std_logic_vector(b3_out1),  -- sfix18_En12
              Enable => Constant_out1,
              a1 => Enabled_Subsystem_out1,  -- sfix18_En12 [4]
              a2 => Enabled_Subsystem_out2,  -- sfix18_En12 [2]
              a3 => Enabled_Subsystem_out3  -- sfix18_En12
              );

  input(0) <= input_0;
  input(1) <= input_1;

  enb <= clk_enable;

  Constant_out1 <= '1';

  outputgen20: FOR k IN 0 TO 1 GENERATE
    b2_out1_1(k) <= std_logic_vector(b2_out1(k));
  END GENERATE;

  outputgen19: FOR k IN 0 TO 3 GENERATE
    b1_out1_1(k) <= std_logic_vector(b1_out1(k));
  END GENERATE;

  outputgen18: FOR k IN 0 TO 1 GENERATE
    w3_out1_1(k) <= std_logic_vector(w3_out1(k));
  END GENERATE;

  outputgen16: FOR k IN 0 TO 1 GENERATE
    outputgen17: FOR k1 IN 0 TO 3 GENERATE
      w2_out1_1(k, k1) <= std_logic_vector(w2_out1(k, k1));
    END GENERATE;
  END GENERATE;

  Enabled_Subsystem1_out6_signed <= signed(Enabled_Subsystem1_out6);

  b3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      b3_out1 <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        b3_out1 <= Enabled_Subsystem1_out6_signed;
      END IF;
    END IF;
  END PROCESS b3_process;


  outputgen15: FOR k IN 0 TO 1 GENERATE
    Enabled_Subsystem1_out5_signed(k) <= signed(Enabled_Subsystem1_out5(k));
  END GENERATE;

  b2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      b2_out1 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        b2_out1 <= Enabled_Subsystem1_out5_signed;
      END IF;
    END IF;
  END PROCESS b2_process;


  outputgen14: FOR k IN 0 TO 1 GENERATE
    b2_out1_2(k) <= std_logic_vector(b2_out1(k));
  END GENERATE;

  outputgen13: FOR k IN 0 TO 3 GENERATE
    Enabled_Subsystem1_out4_signed(k) <= signed(Enabled_Subsystem1_out4(k));
  END GENERATE;

  b1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      b1_out1 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        b1_out1 <= Enabled_Subsystem1_out4_signed;
      END IF;
    END IF;
  END PROCESS b1_process;


  outputgen12: FOR k IN 0 TO 3 GENERATE
    b1_out1_2(k) <= std_logic_vector(b1_out1(k));
  END GENERATE;

  outputgen11: FOR k IN 0 TO 1 GENERATE
    Enabled_Subsystem1_out3_signed(k) <= signed(Enabled_Subsystem1_out3(k));
  END GENERATE;

  w3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      w3_out1 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        w3_out1 <= Enabled_Subsystem1_out3_signed;
      END IF;
    END IF;
  END PROCESS w3_process;


  outputgen10: FOR k IN 0 TO 1 GENERATE
    w3_out1_2(k) <= std_logic_vector(w3_out1(k));
  END GENERATE;

  outputgen8: FOR k IN 0 TO 1 GENERATE
    outputgen9: FOR k1 IN 0 TO 3 GENERATE
      Enabled_Subsystem1_out2_signed(k, k1) <= signed(Enabled_Subsystem1_out2(k, k1));
    END GENERATE;
  END GENERATE;

  c45_Enabled_Subsystem1_out2GEN_LABEL1: FOR d1 IN 0 TO 3 GENERATE
    c45_Enabled_Subsystem1_out2GEN_LABEL: FOR d0 IN 0 TO 1 GENERATE
      c45_Enabled_Subsystem1_out2(d0 + (d1 * 2)) <= Enabled_Subsystem1_out2_signed(d0, d1);
    END GENERATE;
  END GENERATE;

  w2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      c45_w2_out1 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        c45_w2_out1 <= c45_Enabled_Subsystem1_out2;
      END IF;
    END IF;
  END PROCESS w2_process;


  w2_out1GEN_LABEL1: FOR d1 IN 0 TO 3 GENERATE
    w2_out1GEN_LABEL: FOR d0 IN 0 TO 1 GENERATE
      w2_out1(d0, d1) <= c45_w2_out1(d0 + (d1 * 2));
    END GENERATE;
  END GENERATE;

  outputgen6: FOR k IN 0 TO 1 GENERATE
    outputgen7: FOR k1 IN 0 TO 3 GENERATE
      w2_out1_2(k, k1) <= std_logic_vector(w2_out1(k, k1));
    END GENERATE;
  END GENERATE;

  outputgen4: FOR k IN 0 TO 3 GENERATE
    outputgen5: FOR k1 IN 0 TO 1 GENERATE
      w1_out1_1(k, k1) <= std_logic_vector(w1_out1(k, k1));
    END GENERATE;
  END GENERATE;

  outputgen2: FOR k IN 0 TO 3 GENERATE
    outputgen3: FOR k1 IN 0 TO 1 GENERATE
      Enabled_Subsystem1_out1_signed(k, k1) <= signed(Enabled_Subsystem1_out1(k, k1));
    END GENERATE;
  END GENERATE;

  c44_Enabled_Subsystem1_out1GEN_LABEL1: FOR d1 IN 0 TO 1 GENERATE
    c44_Enabled_Subsystem1_out1GEN_LABEL: FOR d0 IN 0 TO 3 GENERATE
      c44_Enabled_Subsystem1_out1(d0 + (d1 * 4)) <= Enabled_Subsystem1_out1_signed(d0, d1);
    END GENERATE;
  END GENERATE;

  w1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      c44_w1_out1 <= (OTHERS => to_signed(16#00000#, 18));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        c44_w1_out1 <= c44_Enabled_Subsystem1_out1;
      END IF;
    END IF;
  END PROCESS w1_process;


  w1_out1GEN_LABEL1: FOR d1 IN 0 TO 1 GENERATE
    w1_out1GEN_LABEL: FOR d0 IN 0 TO 3 GENERATE
      w1_out1(d0, d1) <= c44_w1_out1(d0 + (d1 * 4));
    END GENERATE;
  END GENERATE;

  outputgen: FOR k IN 0 TO 3 GENERATE
    outputgen1: FOR k1 IN 0 TO 1 GENERATE
      w1_out1_2(k, k1) <= std_logic_vector(w1_out1(k, k1));
    END GENERATE;
  END GENERATE;

  ce_out <= clk_enable;

  output <= Enabled_Subsystem_out3;

END rtl;

