-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ANN\L1.vhd
-- Created: 2022-05-21 15:41:35
-- 
-- Generated by MATLAB 9.11 and HDL Coder 3.19
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: L1
-- Source Path: ANN/HDL_ANN/Classify/L1
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.HDL_ANN_pkg.ALL;

ENTITY L1 IS
  PORT( a                                 :   IN    vector_of_std_logic_vector18(0 TO 1);  -- sfix18_En12 [2]
        w                                 :   IN    matrix_of_std_logic_vector18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
        b                                 :   IN    vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
        z_out                             :   OUT   vector_of_std_logic_vector18(0 TO 3);  -- sfix18_En12 [4]
        a_out                             :   OUT   vector_of_std_logic_vector18(0 TO 3)  -- sfix18_En12 [4]
        );
END L1;


ARCHITECTURE rtl OF L1 IS

  -- Signals
  SIGNAL w_signed                         : matrix_of_signed18(0 TO 3, 0 TO 1);  -- sfix18_En12 [4x2]
  SIGNAL s                                : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL selector_out                     : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL s_1                              : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL selector_out_1                   : vector_of_std_logic_vector18(0 TO 7);  -- ufix18 [8]
  SIGNAL selector_out_2                   : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL s_2                              : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL MMul_dot_product_mul_temp        : vector_of_signed36(0 TO 7);  -- sfix36_En24 [8]
  SIGNAL MMul_dot_product_out             : vector_of_signed18(0 TO 7);  -- sfix18_En12 [8]
  SIGNAL reshape_out                      : matrix_of_signed18(0 TO 1, 0 TO 3);  -- sfix18_En12 [2x4]
  SIGNAL selector_out_3                   : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL b_signed                         : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL selector_out_4                   : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL s_3                              : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL MatrixMultiply_out1              : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL Add_out1                         : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL Add_out1_0                       : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Multiply_out1                    : vector_of_signed36(0 TO 3);  -- sfix36_En32 [4]
  SIGNAL Multiply_out1_dtc                : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]
  SIGNAL Multiply_out1_dtc_0              : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_1                       : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL switch_compare_2                 : std_logic;
  SIGNAL Multiply_out1_dtc_1              : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_2                       : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL switch_compare_3                 : std_logic;
  SIGNAL Multiply_out1_dtc_2              : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_3                       : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL switch_compare_4                 : std_logic;
  SIGNAL Multiply_out1_dtc_3              : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_0_1                     : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Leaky_ReLU_out1_0                : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_1_1                     : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Leaky_ReLU_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_2_1                     : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Leaky_ReLU_out1_2                : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Add_out1_3_1                     : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Leaky_ReLU_out1_3                : signed(17 DOWNTO 0);  -- sfix18_En12
  SIGNAL Leaky_ReLU_out1                  : vector_of_signed18(0 TO 3);  -- sfix18_En12 [4]

BEGIN
  outputgen4: FOR k IN 0 TO 3 GENERATE
    outputgen5: FOR k1 IN 0 TO 1 GENERATE
      w_signed(k, k1) <= signed(w(k, k1));
    END GENERATE;
  END GENERATE;

  sGEN_LABEL1: FOR d1 IN 0 TO 1 GENERATE
    sGEN_LABEL: FOR d0 IN 0 TO 3 GENERATE
      s(d0 + (d1 * 4)) <= w_signed(d0, d1);
    END GENERATE;
  END GENERATE;

  selector_out(0) <= s(0);
  selector_out(1) <= s(4);
  selector_out(2) <= s(1);
  selector_out(3) <= s(5);
  selector_out(4) <= s(2);
  selector_out(5) <= s(6);
  selector_out(6) <= s(3);
  selector_out(7) <= s(7);

  s_1GEN_LABEL: FOR d0 IN 0 TO 7 GENERATE
    s_1(d0) <= selector_out(d0);
  END GENERATE;

  selector_out_1(0) <= a(0);
  selector_out_1(1) <= a(1);
  selector_out_1(2) <= a(0);
  selector_out_1(3) <= a(1);
  selector_out_1(4) <= a(0);
  selector_out_1(5) <= a(1);
  selector_out_1(6) <= a(0);
  selector_out_1(7) <= a(1);

  outputgen3: FOR k IN 0 TO 7 GENERATE
    selector_out_2(k) <= signed(selector_out_1(k));
  END GENERATE;

  s_2GEN_LABEL: FOR d0 IN 0 TO 7 GENERATE
    s_2(d0) <= selector_out_2(d0);
  END GENERATE;


  MMul_dot_product_out_gen: FOR t_0 IN 0 TO 7 GENERATE
    MMul_dot_product_mul_temp(t_0) <= s_1(t_0) * s_2(t_0);
    MMul_dot_product_out(t_0) <= MMul_dot_product_mul_temp(t_0)(29 DOWNTO 12);
  END GENERATE MMul_dot_product_out_gen;


  reshape_outGEN_LABEL1: FOR d1 IN 0 TO 3 GENERATE
    reshape_outGEN_LABEL: FOR d0 IN 0 TO 1 GENERATE
      reshape_out(d0, d1) <= MMul_dot_product_out(d0 + (d1 * 2));
    END GENERATE;
  END GENERATE;

  select_0_output : PROCESS (reshape_out)
  BEGIN

    FOR t_01 IN 0 TO 3 LOOP
      selector_out_3(t_01) <= reshape_out(0, t_01);
    END LOOP;

  END PROCESS select_0_output;


  outputgen2: FOR k IN 0 TO 3 GENERATE
    b_signed(k) <= signed(b(k));
  END GENERATE;

  select_1_output : PROCESS (reshape_out)
  BEGIN

    FOR t_02 IN 0 TO 3 LOOP
      selector_out_4(t_02) <= reshape_out(1, t_02);
    END LOOP;

  END PROCESS select_1_output;



  s_3_gen: FOR t_03 IN 0 TO 3 GENERATE
    s_3(t_03) <= selector_out_3(t_03) + selector_out_4(t_03);
  END GENERATE s_3_gen;


  MatrixMultiply_out1GEN_LABEL: FOR d0 IN 0 TO 3 GENERATE
    MatrixMultiply_out1(d0) <= s_3(d0);
  END GENERATE;


  Add_out1_gen: FOR t_04 IN 0 TO 3 GENERATE
    Add_out1(t_04) <= b_signed(t_04) + MatrixMultiply_out1(t_04);
  END GENERATE Add_out1_gen;


  outputgen1: FOR k IN 0 TO 3 GENERATE
    z_out(k) <= std_logic_vector(Add_out1(k));
  END GENERATE;

  Add_out1_0 <= Add_out1(0);

  
  switch_compare_1 <= '1' WHEN Add_out1_0 > to_signed(16#00000#, 18) ELSE
      '0';

  Multiply_out1(0) <= to_signed(16#1999A#, 18) * Add_out1(0);
  Multiply_out1(1) <= to_signed(16#1999A#, 18) * Add_out1(1);
  Multiply_out1(2) <= to_signed(16#1999A#, 18) * Add_out1(2);
  Multiply_out1(3) <= to_signed(16#1999A#, 18) * Add_out1(3);


  Multiply_out1_dtc_gen: FOR ii IN 0 TO 3 GENERATE
    Multiply_out1_dtc(ii) <= resize(Multiply_out1(ii)(35 DOWNTO 20), 18);
  END GENERATE Multiply_out1_dtc_gen;


  Multiply_out1_dtc_0 <= Multiply_out1_dtc(0);

  Add_out1_1 <= Add_out1(1);

  
  switch_compare_2 <= '1' WHEN Add_out1_1 > to_signed(16#00000#, 18) ELSE
      '0';

  Multiply_out1_dtc_1 <= Multiply_out1_dtc(1);

  Add_out1_2 <= Add_out1(2);

  
  switch_compare_3 <= '1' WHEN Add_out1_2 > to_signed(16#00000#, 18) ELSE
      '0';

  Multiply_out1_dtc_2 <= Multiply_out1_dtc(2);

  Add_out1_3 <= Add_out1(3);

  
  switch_compare_4 <= '1' WHEN Add_out1_3 > to_signed(16#00000#, 18) ELSE
      '0';

  Multiply_out1_dtc_3 <= Multiply_out1_dtc(3);

  Add_out1_0_1 <= Add_out1(0);

  
  Leaky_ReLU_out1_0 <= Multiply_out1_dtc_0 WHEN switch_compare_1 = '0' ELSE
      Add_out1_0_1;

  Add_out1_1_1 <= Add_out1(1);

  
  Leaky_ReLU_out1_1 <= Multiply_out1_dtc_1 WHEN switch_compare_2 = '0' ELSE
      Add_out1_1_1;

  Add_out1_2_1 <= Add_out1(2);

  
  Leaky_ReLU_out1_2 <= Multiply_out1_dtc_2 WHEN switch_compare_3 = '0' ELSE
      Add_out1_2_1;

  Add_out1_3_1 <= Add_out1(3);

  
  Leaky_ReLU_out1_3 <= Multiply_out1_dtc_3 WHEN switch_compare_4 = '0' ELSE
      Add_out1_3_1;

  Leaky_ReLU_out1(0) <= Leaky_ReLU_out1_0;
  Leaky_ReLU_out1(1) <= Leaky_ReLU_out1_1;
  Leaky_ReLU_out1(2) <= Leaky_ReLU_out1_2;
  Leaky_ReLU_out1(3) <= Leaky_ReLU_out1_3;

  outputgen: FOR k IN 0 TO 3 GENERATE
    a_out(k) <= std_logic_vector(Leaky_ReLU_out1(k));
  END GENERATE;

END rtl;

